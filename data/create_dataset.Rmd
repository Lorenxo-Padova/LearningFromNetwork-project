---
title: "Create the dataset"
subtitle: "Learning from Networks - project"
author: "Matteo Meneghin"
date: "`r Sys.Date()`"
output: 
  pdf_document: 
    toc: true
    fig_height: 6
    number_sections: true
editor_options: 
  markdown: 
    wrap: 80
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

# The work done in this document

In this files we will create the unique file that will be used in our work. The
final file will be a single .csv/.tsv with 2 columns, and each row will be an
edge between 2 nodes. The nodes will be only of these types, that we will call
'final types': Gene::NCBI, Drug::Pubchem_Compounds, Disease::MESH.

Iterating one file at time we will extract the nodes already in one of the three
final types, and then map the others of a different type to one of the final
types.

## from DOID/OMIM to Disease::MESH

We will create a single `data.frame`, taking data from two different files, and
then using OMIM and DOID as index to a specific MESH value.

-   First file at
    <https://raw.githubusercontent.com/natacourby/Disease_ontologies_for_knowledge_graphs/refs/heads/master/data/prepared_ontologies/cross_references.tsv>

It'a a .tsv, easily parsable with `read_tsv`.

```{r}
if (!require("readr")) install.packages("readr")
library(readr)
cross_ref <- read_tsv(
  "https://raw.githubusercontent.com/natacourby/Disease_ontologies_for_knowledge_graphs/refs/heads/master/data/prepared_ontologies/cross_references.tsv", 
  show_col_types = FALSE
)
MESH_cross_ref <- cross_ref[,c("MESH", "DOID", "OMIM")]

# Removes rows in which MESH=NA, or both DOID and OMIM are NA
MESH_cross_ref <- subset(MESH_cross_ref, 
                        !is.na(MESH) & (!is.na(DOID) | !is.na(OMIM)))
```

We analyze the duplicates, to understand how to manage data.

```{r}
duplicates_summary <- sapply(MESH_cross_ref, function(x) {
  clean_x <- x[!is.na(x)]
  
  total_ids <- length(clean_x)
  unique_ids <- length(unique(clean_x))
  
  return(c(
    Total_IDs = total_ids, 
    Unique_IDs = unique_ids, 
    Dups = total_ids - unique_ids
  ))
})

print(duplicates_summary)
```

We can see that we have 6 duplicates of MESH.

```{r}
if (!require("dplyr")) install.packages("dplyr")
library(dplyr)

mesh_dups <- MESH_cross_ref %>%
  group_by(MESH) %>%
  filter(n() > 1 & !is.na(MESH)) %>%
  arrange(MESH)

print(mesh_dups)
```

This isn't a problem, simply different OMIM or different DOID map to the same
MESH.

There aren't DOID duplicates, so we focus on the OMIM duplicates:

```{r}
omim_dup <- MESH_cross_ref %>%
  group_by(OMIM) %>%
  filter(n() > 1 & !is.na(OMIM))

print(omim_dup)
```

This is a problem, the same OMIM (OMIM_162900.) map to different MESH. 

We can delete row "D009506, NA, OMIM_162900" because the initial D of the code
identifies "Chemicals and Drugs", so we will consider the one with the initial C
that identifies "Diseases". See
<https://en.wikipedia.org/wiki/Medical_Subject_Headings#Categories> for
reference.

```{r}
# Delete the specific row: D009506, NA, OMIM_162900
MESH_cross_ref <- subset(MESH_cross_ref, 
                                 !(MESH == "D009506" & is.na(DOID) 
                                   & OMIM == "OMIM_162900"))
```

We clean `MESH_cross_ref` removing the prefixes and explode lines with mutiple values.

```{r}
if (!require("stringr")) install.packages("stringr")
library(stringr)
if (!require("tidyr")) install.packages("tidyr")
library(tidyr)

# Clean the data.frame removing prefixes
MESH_cross_ref <- MESH_cross_ref %>%
  mutate(
    DOID = str_remove_all(DOID, "DOID[:_]"),
    OMIM = str_remove_all(OMIM, "OMIM[:_]"),
    MESH = str_remove_all(MESH, "MESH:")
  )

# Explodes OMIM and DOID lines with more values
# Separate by "|" or ","
MESH_cross_ref <- MESH_cross_ref %>%
  separate_rows(DOID, sep = "\\|") %>%
  separate_rows(DOID, sep = ",") %>%
  separate_rows(OMIM, sep = "\\|") %>%
  separate_rows(OMIM, sep = ",") %>%
  mutate(across(everything(), str_trim)) %>%
  distinct()
```

-   second file at
    <https://raw.githubusercontent.com/DiseaseOntology/HumanDiseaseOntology/main/src/ontology/doid.obo>

More complex to parse.

```{r }
if (!require("ontologyIndex")) install.packages("ontologyIndex")
library(ontologyIndex)

# Load the ontology (extract_tags = "everything" is required to get 'xref')
url <- "https://raw.githubusercontent.com/DiseaseOntology/HumanDiseaseOntology/main/src/ontology/doid.obo"
doid_onto <- get_ontology(url, extract_tags = "everything")

# Helper function to extract specific prefix from the xref list
extract_xref <- function(xref_list, prefix) {
  # Find all strings in the list that start with the prefix (e.g., "MESH:")
  matches <- grep(paste0("^", prefix), xref_list, value = TRUE)
  # Clean the prefix from the result (e.g., "MESH:D006394" -> "D006394")
  clean_matches <- gsub(paste0("^", prefix, ":"), "", matches)
  # Collapse multiple matches with a comma if they exist
  if (length(clean_matches) > 0) return(paste(clean_matches, collapse = ", ")) else return(NA)
}

MESH_obo <- data.frame(
  MESH = sapply(doid_onto$xref, extract_xref, prefix = "MESH"),
  DOID = doid_onto$id,
  OMIM  = sapply(doid_onto$xref, extract_xref, prefix = "MIM"),
  stringsAsFactors = FALSE
)

rownames(MESH_obo) <- NULL

# Removes rows in which MESH=NA, or both DOID and OMIM are NA
MESH_obo <- subset(MESH_obo, 
                        !is.na(MESH) & (!is.na(DOID) | !is.na(OMIM)))

head(MESH_obo)
```

We analyze the duplicates, to understand how to manage data.

```{r}
duplicates_summary <- sapply(MESH_obo, function(x) {
  clean_x <- x[!is.na(x)]
  
  total_ids <- length(clean_x)
  unique_ids <- length(unique(clean_x))
  
  return(c(
    Total_IDs = total_ids, 
    Unique_IDs = unique_ids, 
    Dups = total_ids - unique_ids
  ))
})
print(duplicates_summary)
```

Also here we need to handle only the OMIM duplicates.

```{r}
omim_dup <- MESH_obo %>%
  group_by(OMIM) %>%
  filter(n() > 1 & !is.na(OMIM))

print(omim_dup)
```

The identical OMIM that map to different MESH is only 137400: it maps to
"fissured tongue" (MESH:D014063) and "geographic tongue" (MESH:D005929).

I will rely on the choice of Monarch Initiative
(<https://monarchinitiative.org/MONDO:0007655>) that choose to associate
OMIM:137400 to MESH:D014063.

```{r}
MESH_obo[MESH_obo$DOID == "DOID:1455" & MESH_obo$MESH == "D005929", "OMIM"] <- NA
```

We clean `MESH_obo` removing the prefixes and explode lines with mutiple values.

```{r}
# Clean the data.frame removing prefixes
MESH_obo <- MESH_obo %>%
  mutate(
    DOID = str_remove_all(DOID, "DOID[:_]"),
    OMIM = str_remove_all(OMIM, "(OMIM|MIM)[:_]"),
    MESH = str_remove_all(MESH, "MESH:")
  )

# Explodes OMIM and DOID lines with more values
# Separate by "|" or ","
MESH_obo <- MESH_obo %>%
  separate_rows(DOID, sep = "\\|") %>%
  separate_rows(DOID, sep = ",") %>%
  separate_rows(OMIM, sep = "\\|") %>%
  separate_rows(OMIM, sep = ",") %>%
  mutate(across(everything(), str_trim)) %>%
  distinct()
```

Merge the 2 `data.frame` in a single one.

```{r}
# Merge MESH_cross_ref and MESH_obo in an unique data.frame
from_DOID_OMIM_to_MESH <- rbind(MESH_cross_ref, MESH_obo)

# Keep only unique rows
from_DOID_OMIM_to_MESH <- unique(from_DOID_OMIM_to_MESH)
```

Sometimes, in the same cell we find 2 different MESH, in the format Cxx\|Dyy (or Cxx,Dyy), as
mentioned before, we will keep only the Cxx types. And others times, more than
one Cxx type. Since there are a lot of cases (\>100), and our team doesn't have
enough biological knowledge, we will simply keep the first one of the list.

```{r}
from_DOID_OMIM_to_MESH <- from_DOID_OMIM_to_MESH %>%
  mutate(
    # Attempt to extract the first code starting with C
    C_code = str_extract(MESH, "(?<=^|[|,])C[^|,]*"),
    # If no C code was found, take everything before the first delimiter
    MESH = coalesce(C_code, str_extract(MESH, "^[^|,]*"))
  ) %>%
  select(-C_code) %>%
  distinct()
from_DOID_OMIM_to_MESH <- unique(from_DOID_OMIM_to_MESH)
```

We analyze the duplicates, to understand how to manage data.

```{r}
duplicates_summary <- sapply(from_DOID_OMIM_to_MESH, function(x) {
  clean_x <- x[!is.na(x)]
  
  total_ids <- length(clean_x)
  unique_ids <- length(unique(clean_x))
  
  return(c(
    Total_IDs = total_ids, 
    Unique_IDs = unique_ids, 
    Dups = total_ids - unique_ids
  ))
})
print(duplicates_summary)
```

Now we handle some specific cases. 

Let's consider this DOID case, but it's the same with OMIM.

If I have these rows: 

- 1, 1, 1 
- 1, 1, NA 
- 1, 1, 2

We will collapse the row with the NA value in one of the other two, still
keeping saved the other full row.

```{r}
# OMIM
from_DOID_OMIM_to_MESH <- from_DOID_OMIM_to_MESH %>%
  group_by(MESH, DOID) %>%
  fill(OMIM, .direction = "downup") %>%
  ungroup() %>%
  distinct()

# DOID
from_DOID_OMIM_to_MESH <- from_DOID_OMIM_to_MESH %>%
  group_by(MESH, OMIM) %>%
  fill(DOID, .direction = "downup") %>%
  ungroup() %>%
  distinct()
```

```{r}
duplicates_summary <- sapply(from_DOID_OMIM_to_MESH, function(x) {
  clean_x <- x[!is.na(x)]
  total_ids <- length(clean_x)
  unique_ids <- length(unique(clean_x))
  return(c(
    Total_IDs = total_ids, 
    Unique_IDs = unique_ids, 
    Dups = total_ids - unique_ids
  ))
})
print(duplicates_summary)
```

Now the duplicates to handle are the half.

Now we handle an other case, in which a pair (DOID,OMIM) map to two different
MESH: we will keep only the first of type Cxx (if exists).

```{r}
from_DOID_OMIM_to_MESH <- from_DOID_OMIM_to_MESH %>%
  group_by(DOID, OMIM) %>%
  mutate(has_C = any(startsWith(MESH, "C"), na.rm = TRUE)) %>%
  filter(!(has_C & startsWith(MESH, "D"))) %>%
  slice(1) %>% 
  ungroup() %>%
  select(-has_C)
```

```{r}
duplicates_summary <- sapply(from_DOID_OMIM_to_MESH, function(x) {
  clean_x <- x[!is.na(x)]
  total_ids <- length(clean_x)
  unique_ids <- length(unique(clean_x))
  return(c(
    Total_IDs = total_ids, 
    Unique_IDs = unique_ids, 
    Dups = total_ids - unique_ids
  ))
})
print(duplicates_summary)
```

Now the duplicates to handle are less.

Now we need to handle an other type of duplicates: (MESH,DOID) map to to
different OMIM and (MESH,OMIM) map to different DOID. This duplicates are not a
problem, simply are many-to-one cases.

Other case to handle: 

- 1, x, A 
- 2, z, A

A needs to be mapped to a single MESH: the first Cxx type found. The other A will be set to NA.

```{r}
# OMIM
from_DOID_OMIM_to_MESH <- from_DOID_OMIM_to_MESH %>%
  group_by(OMIM) %>%
  arrange(desc(startsWith(MESH, "C")), .by_group = TRUE) %>%
  # Edit the OMIM
  mutate(
    OMIM = ifelse(row_number() == 1, OMIM, NA)
  ) %>%
  ungroup()

# DOID
from_DOID_OMIM_to_MESH <- from_DOID_OMIM_to_MESH %>%
  group_by(DOID) %>%
  arrange(desc(startsWith(MESH, "C")), .by_group = TRUE) %>%
  # Edit the DOID
  mutate(
    DOID = ifelse(row_number() == 1, DOID, NA)
  ) %>%
  ungroup()
```

```{r}
duplicates_summary <- sapply(from_DOID_OMIM_to_MESH, function(x) {
  clean_x <- x[!is.na(x)]
  total_ids <- length(clean_x)
  unique_ids <- length(unique(clean_x))
  return(c(
    Total_IDs = total_ids, 
    Unique_IDs = unique_ids, 
    Dups = total_ids - unique_ids
  ))
})
print(duplicates_summary)
```

As seen before, MESH duplicates are not a problem, so our `from_DOID_OMIM_to_MESH` is clean and ready to be used.

## from Uniprot to Gene::NCBI

# From Vitagraph

## Nodes already in final type

Vitagraph is already an unique file. We need only to extract the nodes (and so
the edges) of our interest.

```{r load-vitagraph}
vitaGRAPH <- read.table("vitagraph/vitagraph.tsv", header = TRUE)
head(vitaGRAPH)
```

The nodes (that don't need some transformation) of our interest are:

```{r init-vitagraph-label}
valid_nodes_label_vitagraph <- c("Gene::NCBI","Compound::PubChem_Compounds",
                           "Disease::MESH")
```

```{r vitagraph-already-final}
# Create a search pattern from the valid_nodes_label_vitagraph vector
pattern <- paste(valid_nodes_label_vitagraph, collapse = "|")

# Filter the data frame: 
# check if the pattern exists in both the 'head' AND the 'tail' columns
vitagraph_already_final <- vitaGRAPH[
  grepl(pattern, vitaGRAPH$head) & grepl(pattern, vitaGRAPH$tail), 
  c("head", "tail")
]

head(vitagraph_already_final)

# Save the results to .tsv file 
write.table(vitagraph_already_final, 
            file = "vitagraph_already_final.tsv", 
            sep = "\t", 
            row.names = FALSE, 
            quote = FALSE)

# Save the results to .csv file 
write.csv(vitagraph_already_final, 
          file = "vitagraph_already_final.csv", 
          row.names = FALSE)
```

## Map to MESH

Now we need to consider two other types of nodes that needs to be map:
Disease::DOID and Disease::OMIM.

```{r vitagraph-to-mesh}
# Create clean, direct mapping vectors
# Using setNames avoids creating large intermediate data frames
doid_lookup <- with(from_DOID_OMIM_to_MESH, 
                    setNames(paste0("Disease::MESH:", MESH), 
                             paste0("Disease::DOID:", DOID)))
omim_lookup <- with(from_DOID_OMIM_to_MESH, 
                    setNames(paste0("Disease::MESH:", MESH), 
                             paste0("Disease::OMIM:", OMIM)))

# Combine them into one master lookup
# Filter out NAs to keep the vector lean
master_lookup <- c(doid_lookup, omim_lookup)
master_lookup <- master_lookup[!is.na(names(master_lookup))]

# Extract and mutate ONLY the affected rows
# We use %in% to find rows where head OR tail matches a DOID/OMIM entry
vitagraph_doid_omim_to_mesh <- vitaGRAPH[
  vitaGRAPH$head %in% names(master_lookup) | 
    vitaGRAPH$tail %in% names(master_lookup), 
]

# Perform the substitution
# If the value is in our lookup, replace it; otherwise, keep it as is
vitagraph_doid_omim_to_mesh$head <- ifelse(
  vitagraph_doid_omim_to_mesh$head %in% names(master_lookup),
  master_lookup[vitagraph_doid_omim_to_mesh$head],
  vitagraph_doid_omim_to_mesh$head
)
vitagraph_doid_omim_to_mesh$tail <- ifelse(
  vitagraph_doid_omim_to_mesh$tail %in% names(master_lookup),
  master_lookup[vitagraph_doid_omim_to_mesh$tail],
  vitagraph_doid_omim_to_mesh$tail
)

# Remove duplicates
vitagraph_doid_omim_to_mesh <- unique(vitagraph_doid_omim_to_mesh)

vitagraph_doid_omim_to_mesh <- vitagraph_doid_omim_to_mesh[,c("head", "tail")]
row.names(vitagraph_doid_omim_to_mesh) <- NULL
head(vitagraph_doid_omim_to_mesh)
```

Now we can merge the 2 `data.frame`: `vitagraph_already_final` and `vitagraph_doid_omim_to_mesh`

```{r vitagraph-clean}
vitagraph_clean <- rbind(vitagraph_already_final,vitagraph_doid_omim_to_mesh)
vitagraph_clean <- unique(vitagraph_clean)

# Save the results to .csv file 
write.csv(vitagraph_already_final, 
          file = "vitagraph_clean.csv", 
          row.names = FALSE)
```

```
